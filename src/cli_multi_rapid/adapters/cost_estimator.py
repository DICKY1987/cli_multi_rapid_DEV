#!/usr/bin/env python3"""Cost Estimator AdapterEstimates workflow token usage and rough USD cost using the Router'scost model and emits a structured artifact."""from __future__ import annotationsfrom pathlib import Pathfrom typing import Anyfrom .base_adapter import AdapterResult, AdapterType, BaseAdapter# Avoid circular import by importing Router lazilyclass CostEstimatorAdapter(BaseAdapter):    """Adapter that estimates cost for a YAML workflow file."""    def __init__(self) -> None:        super().__init__(            name="cost_estimator",            adapter_type=AdapterType.DETERMINISTIC,            description="Estimate workflow token/$$ cost and emit artifact",        )    def execute(        self,        step: dict[str, Any],        context: dict[str, Any] | None = None,        files: str | None = None,    ) -> AdapterResult:        self._log_execution_start(step)        try:            params = self._extract_with_params(step)            emit_paths = self._extract_emit_paths(step)            workflow_path = Path(                params.get("workflow", ".ai/workflows/AI_WORKFLOW_DEMO.yaml")            )            if not workflow_path.exists():                return AdapterResult(                    success=False, error=f"Workflow not found: {workflow_path}"                )            import yaml            with open(workflow_path, encoding="utf-8") as f:                workflow = yaml.safe_load(f) or {}            # Import Router lazily to avoid circular imports            from ..router import Router            router = Router()            # Use basic cost estimation if enhanced method not available            if hasattr(router, "estimate_workflow_cost"):                estimate = router.estimate_workflow_cost(workflow)            else:                # Fallback cost estimation                steps = workflow.get("steps", [])                estimate = {                    "total_estimated_tokens": len(steps) * 1000,                    "estimated_cost_usd": len(steps) * 0.01,                    "steps_analyzed": len(steps),                }            artifact_obj = {                "timestamp": __import__("datetime").datetime.utcnow().isoformat(),                "type": "ai_cost_estimate",                **estimate,            }            written = self._write_artifacts(emit_paths, artifact_obj)            return AdapterResult(                success=True, tokens_used=0, artifacts=written, metadata=estimate            )        except Exception as e:            return AdapterResult(success=False, error=f"cost_estimator failed: {e}")
"""Tool registry for detection, configuration, and selection."""from __future__ import annotationsimport osimport refrom dataclasses import dataclassimport yamlfrom .process import ProcessRunner, ToolErrorfrom .tools_base import ToolProbe@dataclassclass ToolConfig:    """Configuration for a specific tool."""    path: str | None = None    args: dict[str, str] | None = None    timeout_ms: int = 30000    env: dict[str, str] | None = None@dataclassclass ToolSelection:    """Tool selection configuration."""    vcs: str = "git"    containers: str = "docker"    editor: str = "vscode"    js_runtime: str = "node"    ai_cli: str = "claude"    python_quality: dict[str, bool] = None    precommit: bool = True    paths: dict[str, str] = None    def __post_init__(self):        if self.python_quality is None:            self.python_quality = {                "ruff": True,                "mypy": True,                "bandit": True,                "semgrep": True,            }        if self.paths is None:            self.paths = {}def load_config(config_path: str = "config/tool_adapters.yaml") -> ToolSelection:    """Load tool configuration from YAML file."""    if not os.path.exists(config_path):        return ToolSelection()    try:        with open(config_path, encoding="utf-8") as f:            data = yaml.safe_load(f) or {}        return ToolSelection(            vcs=data.get("vcs", "git"),            containers=data.get("containers", "docker"),            editor=data.get("editor", "vscode"),            js_runtime=data.get("js_runtime", "node"),            ai_cli=data.get("ai_cli", "claude"),            python_quality=data.get(                "python_quality",                {                    "ruff": True,                    "mypy": True,                    "bandit": True,                    "semgrep": True,                },            ),            precommit=data.get("precommit", True),            paths=data.get("paths", {}),        )    except Exception:        return ToolSelection()def _extract_version(output: str) -> str | None:    """Extract version from tool output."""    if not output:        return None    # Common version patterns    patterns = [        r"(\d+\.\d+\.\d+)",        r"v(\d+\.\d+\.\d+)",        r"version\s+(\d+\.\d+\.\d+)",        r"(\d+\.\d+)",    ]    for pattern in patterns:        match = re.search(pattern, output, re.IGNORECASE)        if match:            return match.group(1)    return Nonedef probe_binary(    runner: ProcessRunner, binary: str, version_args: list[str]) -> ToolProbe:    """Probe a binary for version and availability."""    try:        res = runner.run([binary] + version_args)        version = _extract_version(res.stdout or res.stderr)        return ToolProbe(name=binary, path=binary, version=version, ok=res.code == 0)    except ToolError as e:        return ToolProbe(name=binary, path=None, version=None, ok=False, details=str(e))def detect_all(runner: ProcessRunner) -> dict[str, ToolProbe]:    """Detect all available tools."""    sel = load_config()    # Candidate paths for Windows defaults; env PATH will be used if no explicit path provided    paths = {        "git": sel.paths.get("git") or "git",        "gh": sel.paths.get("gh") or "gh",        "docker": sel.paths.get("docker") or "docker",        "code": sel.paths.get("code") or "code",        "node": sel.paths.get("node") or "node",        "npx": sel.paths.get("npx") or "npx",        "openai": sel.paths.get("openai") or "openai",        "claude": sel.paths.get("claude") or "claude",        "pre-commit": sel.paths.get("pre_commit") or "pre-commit",        "ruff": sel.paths.get("ruff") or "ruff",        "mypy": sel.paths.get("mypy") or "mypy",        "bandit": sel.paths.get("bandit") or "bandit",        "semgrep": sel.paths.get("semgrep") or "semgrep",    }    probes: dict[str, ToolProbe] = {}    # Core tools    probes["git"] = probe_binary(runner, paths["git"], ["--version"])    probes["gh"] = probe_binary(runner, paths["gh"], ["--version"])    probes["docker"] = probe_binary(runner, paths["docker"], ["--version"])    probes["code"] = probe_binary(runner, paths["code"], ["--version"])    probes["node"] = probe_binary(runner, paths["node"], ["-v"])    probes["npx"] = probe_binary(runner, paths["npx"], ["--version"])    # AI CLIs: allow either    if sel.ai_cli == "openai":        # Prefer direct binary when available        if paths.get("openai"):            probes["openai"] = probe_binary(runner, paths["openai"], ["--version"])        else:            # Try via npx            probes["openai"] = probe_binary(                runner, paths["npx"], ["openai", "--version"]            )    else:        probes["claude"] = probe_binary(runner, paths["claude"], ["--version"])    # Python quality tools    probes["pre-commit"] = probe_binary(runner, paths["pre-commit"], ["--version"])    probes["ruff"] = probe_binary(runner, paths["ruff"], ["--version"])    probes["mypy"] = probe_binary(runner, paths["mypy"], ["--version"])    probes["bandit"] = probe_binary(runner, paths["bandit"], ["--version"])    probes["semgrep"] = probe_binary(runner, paths["semgrep"], ["--version"])    return probesdef generate_doctor_report(probes: dict[str, ToolProbe]) -> str:    """Generate a health report for detected tools."""    lines = ["Tool Health Report", "=" * 20, ""]    for name, probe in probes.items():        status = "Γ£ô" if probe.ok else "Γ£ù"        version = f" (v{probe.version})" if probe.version else ""        path = f" at {probe.path}" if probe.path else ""        details = f" - {probe.details}" if probe.details else ""        lines.append(f"{status} {name}{version}{path}{details}")    # Summary    ok_count = sum(1 for p in probes.values() if p.ok)    total_count = len(probes)    lines.extend(["", f"Summary: {ok_count}/{total_count} tools available"])    return "\n".join(lines)def get_selected_tool_path(tool_name: str, tool_type: str) -> str:    """Get the configured path for a specific tool."""    sel = load_config()    # Check configured paths first    if hasattr(sel, "paths") and sel.paths and tool_name in sel.paths:        return sel.paths[tool_name]    # Environment variable override    env_var = f"{tool_name.upper()}_PATH"    env_path = os.environ.get(env_var)    if env_path:        return env_path    # Default to tool name (relies on PATH)    return tool_name
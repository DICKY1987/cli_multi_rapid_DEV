"""Container management adapters."""from __future__ import annotationsfrom .process import CommandResult, ProcessRunnerfrom .registry import get_selected_tool_pathfrom .tools_base import Containers, ToolProbeclass DockerAdapter:    """Docker container management adapter."""    def __init__(self, runner: ProcessRunner) -> None:        self.runner = runner        self.binary = get_selected_tool_path("docker", "containers")    def version(self) -> ToolProbe:        """Get Docker version information."""        try:            res = self.runner.run([self.binary, "--version"])            # Extract version from output like "Docker version 24.0.5, build ced0996"            version = None            if res.stdout:                parts = res.stdout.strip().split()                if len(parts) >= 3:                    version = parts[2].rstrip(",")            return ToolProbe(                name="docker",                path=self.binary,                version=version,                ok=res.code == 0,                details=res.stderr if res.code != 0 else None,            )        except Exception as e:            return ToolProbe(                name="docker",                path=None,                version=None,                ok=False,                details=str(e),            )    def compose_up(        self, compose_file: str = "docker-compose.yml", detach: bool = True    ) -> CommandResult:        """Start containers with docker-compose."""        args = [self.binary, "compose", "-f", compose_file, "up"]        if detach:            args.append("-d")        return self.runner.run(args)    def compose_down(self, compose_file: str = "docker-compose.yml") -> CommandResult:        """Stop containers with docker-compose."""        return self.runner.run([self.binary, "compose", "-f", compose_file, "down"])    def ps(self) -> CommandResult:        """List running containers."""        return self.runner.run([self.binary, "ps"])    def run(        self, image: str, command: list[str] | None = None, **kwargs    ) -> CommandResult:        """Run a container."""        args = [self.binary, "run"]        # Handle common kwargs        if kwargs.get("detach"):            args.append("-d")        if kwargs.get("rm"):            args.append("--rm")        if kwargs.get("interactive"):            args.append("-i")        if kwargs.get("tty"):            args.append("-t")        # Environment variables        env_vars = kwargs.get("environment", {})        for key, value in env_vars.items():            args.extend(["-e", f"{key}={value}"])        # Volume mounts        volumes = kwargs.get("volumes", [])        for volume in volumes:            args.extend(["-v", volume])        # Port mappings        ports = kwargs.get("ports", [])        for port in ports:            args.extend(["-p", port])        # Working directory        workdir = kwargs.get("workdir")        if workdir:            args.extend(["-w", workdir])        # Container name        name = kwargs.get("name")        if name:            args.extend(["--name", name])        args.append(image)        if command:            args.extend(command)        return self.runner.run(args)    def build(        self, path: str = ".", tag: str | None = None, dockerfile: str = "Dockerfile"    ) -> CommandResult:        """Build a Docker image."""        args = [self.binary, "build", "-f", dockerfile]        if tag:            args.extend(["-t", tag])        args.append(path)        return self.runner.run(args)    def pull(self, image: str) -> CommandResult:        """Pull a Docker image."""        return self.runner.run([self.binary, "pull", image])    def push(self, image: str) -> CommandResult:        """Push a Docker image."""        return self.runner.run([self.binary, "push", image])    def stop(self, container: str) -> CommandResult:        """Stop a container."""        return self.runner.run([self.binary, "stop", container])    def rm(self, container: str, force: bool = False) -> CommandResult:        """Remove a container."""        args = [self.binary, "rm"]        if force:            args.append("-f")        args.append(container)        return self.runner.run(args)    def logs(        self, container: str, follow: bool = False, tail: int | None = None    ) -> CommandResult:        """Get container logs."""        args = [self.binary, "logs"]        if follow:            args.append("-f")        if tail is not None:            args.extend(["--tail", str(tail)])        args.append(container)        return self.runner.run(args)    def exec(        self,        container: str,        command: list[str],        interactive: bool = False,        tty: bool = False,    ) -> CommandResult:        """Execute command in running container."""        args = [self.binary, "exec"]        if interactive:            args.append("-i")        if tty:            args.append("-t")        args.append(container)        args.extend(command)        return self.runner.run(args)    def info(self) -> CommandResult:        """Get Docker system information."""        return self.runner.run([self.binary, "info"])    def images(self) -> CommandResult:        """List Docker images."""        return self.runner.run([self.binary, "images"])def create_containers_adapter(    runner: ProcessRunner, container_type: str = "docker") -> Containers:    """Factory function to create containers adapter."""    if container_type == "docker":        return DockerAdapter(runner)    else:        raise ValueError(f"Unsupported container type: {container_type}")
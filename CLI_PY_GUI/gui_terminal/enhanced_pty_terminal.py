#!/usr/bin/env python3
"""
Enhanced PTY Terminal Runner - Production Ready
Addresses all identified gaps and implements enterprise-grade features
"""

import json
import logging
import os
import pty
import re
import select
import shlex  # FIX: Added missing import
import signal
import subprocess
import sys
import time
from dataclasses import dataclass, field
from enum import Enum
from typing import Any, Dict, List, Optional

try:
    from PyQt6.QtCore import *
    from PyQt6.QtGui import *
    from PyQt6.QtWidgets import *
    PYQT_VERSION = 6
except ImportError:
    from PyQt5.QtCore import *
    from PyQt5.QtGui import *
    from PyQt5.QtWidgets import *
    PYQT_VERSION = 5

# Windows-specific imports
if sys.platform == 'win32':
    try:
        import ctypes
        from ctypes import wintypes

        import winpty
        WINDOWS_PTY_AVAILABLE = True
    except ImportError:
        WINDOWS_PTY_AVAILABLE = False

# Security and logging setup
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('gui_terminal.log'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

class SecurityLevel(Enum):
    UNRESTRICTED = "unrestricted"
    BASIC = "basic"
    STRICT = "strict"
    PARANOID = "paranoid"

class CommandStatus(Enum):
    PENDING = "pending"
    RUNNING = "running"
    COMPLETED = "completed"
    FAILED = "failed"
    INTERRUPTED = "interrupted"

@dataclass
class SecurityConfig:
    """Security configuration for command execution"""
    level: SecurityLevel = SecurityLevel.BASIC
    allowed_commands: List[str] = field(default_factory=lambda: [
        "ls", "dir", "pwd", "cd", "echo", "cat", "type", "grep", "find",
        "python", "pip", "git", "node", "npm", "docker", "kubectl"
    ])
    blocked_commands: List[str] = field(default_factory=lambda: [
        "rm", "del", "format", "fdisk", "dd", "mkfs", "sudo", "su"
    ])
    max_execution_time: int = 300  # 5 minutes
    max_memory_mb: int = 512
    allow_shell_execution: bool = True
    audit_commands: bool = True
    require_confirmation: List[str] = field(default_factory=lambda: [
        "rm", "del", "format", "sudo"
    ])

@dataclass
class CommandRequest:
    """Enhanced command request with security and metadata"""
    tool: str
    args: List[str]
    cwd: str
    env: Dict[str, str]
    command_preview: str = ""  # FIX: Added missing field
    timeout: Optional[int] = None
    shell: bool = False
    security_level: SecurityLevel = SecurityLevel.BASIC
    user_id: str = "default"
    session_id: str = "default"

@dataclass
class CommandResult:
    """Enhanced command result with detailed metadata"""
    exit_code: int
    stdout: str = ""
    stderr: str = ""
    execution_time: float = 0.0
    memory_used_mb: float = 0.0
    status: CommandStatus = CommandStatus.COMPLETED
    security_violations: List[str] = field(default_factory=list)
    process_id: Optional[int] = None

class SecurityValidator:
    """Enhanced security validation and sandboxing"""

    def __init__(self, config: SecurityConfig):
        self.config = config
        self.audit_log = []

    def validate_command(self, request: CommandRequest) -> tuple[bool, List[str]]:
        """Validate command against security policies"""
        violations = []

        # Command whitelist/blacklist validation
        if self.config.level in [SecurityLevel.STRICT, SecurityLevel.PARANOID]:
            if request.tool not in self.config.allowed_commands:
                violations.append(f"Command '{request.tool}' not in allowed list")

        if request.tool in self.config.blocked_commands:
            violations.append(f"Command '{request.tool}' is blocked")

        # Argument validation
        dangerous_patterns = [
            r'[;&|`$()]',  # Shell metacharacters
            r'\.\./.*',    # Directory traversal
            r'--?password', # Password arguments
            r'sudo|su',    # Privilege escalation
        ]

        full_command = f"{request.tool} {' '.join(request.args)}"
        for pattern in dangerous_patterns:
            if re.search(pattern, full_command, re.IGNORECASE):
                violations.append(f"Dangerous pattern detected: {pattern}")

        # Path validation
        if not os.path.exists(request.cwd):
            violations.append(f"Working directory does not exist: {request.cwd}")

        # Audit logging
        if self.config.audit_commands:
            self.audit_log.append({
                "timestamp": time.time(),
                "user_id": request.user_id,
                "session_id": request.session_id,
                "command": full_command,
                "cwd": request.cwd,
                "violations": violations
            })

        return len(violations) == 0, violations

    def sanitize_command(self, request: CommandRequest) -> CommandRequest:
        """Sanitize command arguments"""
        # Remove dangerous characters from arguments
        sanitized_args = []
        for arg in request.args:
            # Remove null bytes and control characters
            sanitized_arg = re.sub(r'[\x00-\x1f\x7f]', '', arg)
            sanitized_args.append(sanitized_arg)

        request.args = sanitized_args
        return request

class ANSIProcessor:
    """Enhanced ANSI escape sequence processor"""

    def __init__(self):
        self.reset()

    def reset(self):
        """Reset terminal state"""
        self.cursor_row = 0
        self.cursor_col = 0
        self.saved_cursor_row = 0
        self.saved_cursor_col = 0
        self.current_attrs = {}
        self.screen_buffer = []

    def process_ansi(self, text: str) -> str:
        """Process ANSI escape sequences and return formatted text"""
        # Handle carriage return (overwrite line)
        if '\r' in text and '\n' not in text:
            parts = text.split('\r')
            if len(parts) > 1:
                return parts[-1]  # Return last part after CR

        # Handle backspace
        text = self._process_backspace(text)

        # Handle ANSI escape sequences
        text = self._process_escape_sequences(text)

        return text

    def _process_backspace(self, text: str) -> str:
        """Process backspace characters"""
        result = []
        for char in text:
            if char == '\b' and result:
                result.pop()
            else:
                result.append(char)
        return ''.join(result)

    def _process_escape_sequences(self, text: str) -> str:
        """Process ANSI escape sequences"""
        # CSI K - Erase to end of line
        text = re.sub(r'\x1b\[K', '', text)

        # CSI sequences for cursor movement and colors
        # This is a simplified implementation - full VT100 would be more complex
        ansi_escape = re.compile(r'\x1b\[[0-?]*[ -/]*[@-~]')
        return ansi_escape.sub('', text)

class EnhancedPTYWorker(QThread):
    """Enhanced PTY worker with better error handling and features"""

    data_received = pyqtSignal(str)
    process_finished = pyqtSignal(CommandResult)
    process_started = pyqtSignal(int)  # Process ID
    error_occurred = pyqtSignal(str)

    def __init__(self, request: CommandRequest, security_config: SecurityConfig):
        super().__init__()
        self.request = request
        self.security_config = security_config
        self.security_validator = SecurityValidator(security_config)
        self.ansi_processor = ANSIProcessor()
        self.process = None
        self.pty_fd = None
        self.process_id = None
        self.start_time = None
        self.should_stop = False

    def run(self):
        """Main PTY worker thread"""
        try:
            self.start_time = time.time()

            # Validate and sanitize command
            is_valid, violations = self.security_validator.validate_command(self.request)
            if not is_valid:
                result = CommandResult(
                    exit_code=-1,
                    stderr=f"Security violations: {'; '.join(violations)}",
                    status=CommandStatus.FAILED,
                    security_violations=violations
                )
                self.process_finished.emit(result)
                return

            self.request = self.security_validator.sanitize_command(self.request)

            # Execute command based on platform
            if sys.platform == 'win32':
                self._run_windows()
            else:
                self._run_unix()

        except Exception as e:
            logger.exception(f"PTY worker error: {e}")
            self.error_occurred.emit(str(e))
            result = CommandResult(
                exit_code=-1,
                stderr=str(e),
                status=CommandStatus.FAILED
            )
            self.process_finished.emit(result)

    def _run_unix(self):
        """Run command on Unix-like systems"""
        try:
            # Create PTY
            master_fd, slave_fd = pty.openpty()
            self.pty_fd = master_fd

            # Build command
            if self.request.shell:
                cmd = f"{self.request.tool} {' '.join(self.request.args)}"
                exec_args = ["/bin/sh", "-c", cmd]
            else:
                exec_args = [self.request.tool] + self.request.args

            # Spawn process
            self.process = subprocess.Popen(
                exec_args,
                stdin=slave_fd,
                stdout=slave_fd,
                stderr=slave_fd,
                cwd=self.request.cwd,
                env=self.request.env,
                preexec_fn=os.setsid,
                close_fds=True
            )

            os.close(slave_fd)  # Close slave end in parent
            self.process_id = self.process.pid
            self.process_started.emit(self.process_id)

            # Read output
            self._read_pty_output_unix()

        except Exception as e:
            logger.exception(f"Unix PTY execution error: {e}")
            raise

    def _run_windows(self):
        """Run command on Windows using ConPTY/winpty"""
        if not WINDOWS_PTY_AVAILABLE:
            raise RuntimeError("Windows PTY support not available. Install pywinpty.")

        try:
            # Build command for Windows
            if self.request.shell:
                cmd = f"{self.request.tool} {' '.join(self.request.args)}"
            else:
                # Use shlex.join if available (Python 3.8+), otherwise manual join
                if hasattr(shlex, 'join'):
                    cmd = shlex.join([self.request.tool] + self.request.args)
                else:
                    cmd = subprocess.list2cmdline([self.request.tool] + self.request.args)

            # Create winpty process
            self.process = winpty.PtyProcess.spawn(
                cmd,
                cwd=self.request.cwd,
                env=self.request.env
            )

            self.process_id = self.process.pid if hasattr(self.process, 'pid') else None
            if self.process_id:
                self.process_started.emit(self.process_id)

            # Read output
            self._read_pty_output_windows()

        except Exception as e:
            logger.exception(f"Windows PTY execution error: {e}")
            raise

    def _read_pty_output_unix(self):
        """Read PTY output on Unix systems"""
        stdout_data = []
        stderr_data = []

        try:
            while not self.should_stop:
                # Check if process is still running
                poll_result = self.process.poll()
                if poll_result is not None:
                    break

                # Select on PTY file descriptor
                ready, _, _ = select.select([self.pty_fd], [], [], 0.1)
                if ready:
                    try:
                        data = os.read(self.pty_fd, 1024)
                        if data:
                            text = data.decode('utf-8', errors='replace')
                            processed_text = self.ansi_processor.process_ansi(text)
                            stdout_data.append(processed_text)
                            self.data_received.emit(processed_text)
                    except OSError:
                        break

            # Wait for process to complete
            exit_code = self.process.wait()

        except Exception as e:
            logger.exception(f"Error reading PTY output: {e}")
            exit_code = -1
        finally:
            if self.pty_fd:
                os.close(self.pty_fd)

        # Calculate execution metrics
        execution_time = time.time() - self.start_time if self.start_time else 0

        result = CommandResult(
            exit_code=exit_code,
            stdout=''.join(stdout_data),
            stderr=''.join(stderr_data),
            execution_time=execution_time,
            status=CommandStatus.COMPLETED if exit_code == 0 else CommandStatus.FAILED,
            process_id=self.process_id
        )

        self.process_finished.emit(result)

    def _read_pty_output_windows(self):
        """Read PTY output on Windows systems"""
        stdout_data = []

        try:
            while not self.should_stop:
                # Check if process is alive
                if not self.process.isalive():
                    break

                try:
                    # Read available data
                    data = self.process.read(1024, blocking=False)
                    if data:
                        text = data.decode('utf-8', errors='replace')
                        processed_text = self.ansi_processor.process_ansi(text)
                        stdout_data.append(processed_text)
                        self.data_received.emit(processed_text)
                    else:
                        time.sleep(0.01)  # Small delay to prevent CPU spinning
                except:
                    break

            # Wait for process completion
            exit_code = self.process.wait()

        except Exception as e:
            logger.exception(f"Error reading Windows PTY output: {e}")
            exit_code = -1

        # Calculate execution metrics
        execution_time = time.time() - self.start_time if self.start_time else 0

        result = CommandResult(
            exit_code=exit_code,
            stdout=''.join(stdout_data),
            execution_time=execution_time,
            status=CommandStatus.COMPLETED if exit_code == 0 else CommandStatus.FAILED,
            process_id=self.process_id
        )

        self.process_finished.emit(result)

    def send_input(self, text: str):
        """Send input to the PTY"""
        try:
            if sys.platform == 'win32' and self.process:
                self.process.write(text.encode('utf-8'))
            elif self.pty_fd:
                os.write(self.pty_fd, text.encode('utf-8'))
        except Exception as e:
            logger.warning(f"Failed to send input: {e}")

    def send_signal(self, sig: signal.Signals):
        """Send signal to the process"""
        try:
            if sys.platform == 'win32':
                self._send_signal_windows(sig)
            else:
                self._send_signal_unix(sig)
        except Exception as e:
            logger.warning(f"Failed to send signal {sig}: {e}")

    def _send_signal_unix(self, sig: signal.Signals):
        """Send signal on Unix systems"""
        if self.process_id:
            os.killpg(self.process_id, sig)

    def _send_signal_windows(self, sig: signal.Signals):
        """Send signal on Windows systems"""
        if sig == signal.SIGINT:
            # Try to send Ctrl+C
            if self.process:
                try:
                    # Send Ctrl+C character to PTY
                    self.process.write(b'\x03')
                except:
                    # Fallback: terminate process
                    if hasattr(self.process, 'terminate'):
                        self.process.terminate()
        elif sig == signal.SIGTERM:
            if self.process and hasattr(self.process, 'terminate'):
                self.process.terminate()

    def resize_pty(self, cols: int, rows: int):
        """Resize the PTY"""
        try:
            if sys.platform != 'win32' and self.pty_fd:
                import fcntl
                import termios
                s = struct.pack('HHHH', rows, cols, 0, 0)
                fcntl.ioctl(self.pty_fd, termios.TIOCSWINSZ, s)
            elif sys.platform == 'win32' and self.process:
                # Windows PTY resize (if supported by winpty)
                if hasattr(self.process, 'set_size'):
                    self.process.set_size(cols, rows)
        except Exception as e:
            logger.warning(f"Failed to resize PTY: {e}")

    def stop(self):
        """Stop the PTY worker"""
        self.should_stop = True
        if self.process:
            try:
                self.send_signal(signal.SIGTERM)
                time.sleep(0.1)
                if sys.platform != 'win32' and self.process.poll() is None:
                    self.send_signal(signal.SIGKILL)
            except:
                pass

class EnhancedTerminalWidget(QTextEdit):
    """Enhanced terminal widget with better features"""

    def __init__(self):
        super().__init__()
        self.setup_terminal()
        self.command_history = []
        self.history_index = -1

    def setup_terminal(self):
        """Setup terminal appearance and behavior"""
        # Terminal appearance
        font = QFont("Consolas", 10)
        font.setFixedPitch(True)
        self.setFont(font)

        # Dark terminal theme
        self.setStyleSheet("""
            QTextEdit {
                background-color: #1e1e1e;
                color: #ffffff;
                border: 1px solid #3c3c3c;
                selection-background-color: #404040;
            }
        """)

        # Terminal settings
        self.setAcceptRichText(False)
        self.setUndoRedoEnabled(False)
        self.setLineWrapMode(QTextEdit.LineWrapMode.WidgetWidth)

    def append_output(self, text: str):
        """Append output to terminal with proper formatting"""
        # Move cursor to end
        cursor = self.textCursor()
        cursor.movePosition(QTextCursor.MoveOperation.End)
        self.setTextCursor(cursor)

        # Insert text
        self.insertPlainText(text)

        # Auto-scroll to bottom
        scrollbar = self.verticalScrollBar()
        scrollbar.setValue(scrollbar.maximum())

    def clear_terminal(self):
        """Clear terminal content"""
        self.clear()

    def get_terminal_size(self) -> tuple[int, int]:
        """Get terminal size in characters"""
        font_metrics = QFontMetrics(self.font())
        char_width = font_metrics.horizontalAdvance('M')
        char_height = font_metrics.height()

        cols = max(1, self.width() // char_width)
        rows = max(1, self.height() // char_height)

        return cols, rows

    def resizeEvent(self, event):
        """Handle resize events"""
        super().resizeEvent(event)
        # Emit resize signal for PTY
        cols, rows = self.get_terminal_size()
        if hasattr(self, 'pty_worker') and self.pty_worker:
            self.pty_worker.resize_pty(cols, rows)

class CommandHistoryWidget(QWidget):
    """Command history and management widget"""

    command_selected = pyqtSignal(str)

    def __init__(self):
        super().__init__()
        self.setup_ui()
        self.history = []

    def setup_ui(self):
        """Setup history UI"""
        layout = QVBoxLayout(self)

        # Title
        title = QLabel("Command History")
        title.setStyleSheet("font-weight: bold; padding: 5px;")
        layout.addWidget(title)

        # History list
        self.history_list = QListWidget()
        self.history_list.setStyleSheet("""
            QListWidget {
                background-color: #2d2d2d;
                color: white;
                border: 1px solid #3c3c3c;
                font-family: monospace;
            }
            QListWidget::item {
                padding: 2px 5px;
                border-bottom: 1px solid #3c3c3c;
            }
            QListWidget::item:selected {
                background-color: #404040;
            }
        """)
        self.history_list.itemDoubleClicked.connect(self.on_item_selected)
        layout.addWidget(self.history_list)

        # Clear button
        clear_btn = QPushButton("Clear History")
        clear_btn.clicked.connect(self.clear_history)
        layout.addWidget(clear_btn)

    def add_command(self, command: str):
        """Add command to history"""
        if command and command not in self.history:
            self.history.append(command)
            self.history_list.addItem(command)

            # Limit history size
            if len(self.history) > 100:
                self.history.pop(0)
                self.history_list.takeItem(0)

    def on_item_selected(self, item):
        """Handle history item selection"""
        self.command_selected.emit(item.text())

    def clear_history(self):
        """Clear command history"""
        self.history.clear()
        self.history_list.clear()

class SystemIntegration:
    """System integration utilities"""

    @staticmethod
    def open_system_terminal(cwd: str = None):
        """Open system terminal at specified directory"""
        cwd = cwd or os.getcwd()

        try:
            if sys.platform == 'win32':
                # Try Windows Terminal first, then PowerShell, then CMD
                terminals = [
                    ['wt', '-d', cwd],
                    ['powershell', '-NoExit', '-Command', f'Set-Location "{cwd}"'],
                    ['cmd', '/K', f'cd /D "{cwd}"']
                ]

                for terminal in terminals:
                    try:
                        subprocess.Popen(terminal)
                        return
                    except FileNotFoundError:
                        continue

            elif sys.platform == 'darwin':
                # macOS Terminal
                script = f'tell application "Terminal" to do script "cd \\"{cwd}\\""'
                subprocess.Popen(['osascript', '-e', script])

            else:
                # Linux - try common terminals
                terminals = [
                    ['gnome-terminal', '--working-directory', cwd],
                    ['konsole', '--workdir', cwd],
                    ['xterm', '-e', f'cd "{cwd}"; bash'],
                    ['mate-terminal', '--working-directory', cwd]
                ]

                for terminal in terminals:
                    try:
                        subprocess.Popen(terminal)
                        return
                    except FileNotFoundError:
                        continue

        except Exception as e:
            logger.warning(f"Failed to open system terminal: {e}")

    @staticmethod
    def reveal_in_file_manager(path: str):
        """Reveal file/directory in system file manager"""
        try:
            if sys.platform == 'win32':
                os.startfile(path)
            elif sys.platform == 'darwin':
                subprocess.Popen(['open', path])
            else:
                subprocess.Popen(['xdg-open', path])
        except Exception as e:
            logger.warning(f"Failed to reveal in file manager: {e}")

class EnhancedTerminalTab(QWidget):
    """Enhanced terminal tab with all features"""

    def __init__(self, command_req: CommandRequest, security_config: SecurityConfig):
        super().__init__()
        self.command_req = command_req
        self.security_config = security_config
        self.pty_worker = None
        self.current_result = None

        self.setup_ui()

    def setup_ui(self):
        """Setup enhanced terminal tab UI"""
        main_layout = QHBoxLayout(self)

        # Left side - Terminal
        left_widget = QWidget()
        left_layout = QVBoxLayout(left_widget)

        # Command preview strip
        preview_layout = QHBoxLayout()
        preview_label = QLabel("Command:")
        preview_label.setStyleSheet("font-weight: bold; color: #888; padding: 2px;")

        self.cmd_display = QLabel(self.command_req.command_preview)
        self.cmd_display.setStyleSheet("""
            font-family: monospace;
            background: #2d2d2d;
            padding: 4px 8px;
            border-radius: 3px;
            color: #ffffff;
            border: 1px solid #3c3c3c;
        """)
        self.cmd_display.setWordWrap(True)

        preview_layout.addWidget(preview_label)
        preview_layout.addWidget(self.cmd_display, 1)
        left_layout.addLayout(preview_layout)

        # Terminal widget
        self.terminal = EnhancedTerminalWidget()
        left_layout.addWidget(self.terminal, 1)

        # Input and controls
        controls_layout = QHBoxLayout()

        # Input line
        self.input_line = QLineEdit()
        self.input_line.setFont(QFont("Consolas", 10))
        self.input_line.setPlaceholderText("Type commands here... (Press Enter to send)")
        self.input_line.returnPressed.connect(self.send_input)
        controls_layout.addWidget(self.input_line, 1)

        # Signal buttons
        signal_layout = QHBoxLayout()

        self.ctrl_c_btn = QPushButton("Ctrl+C")
        self.ctrl_c_btn.setStyleSheet("background-color: #ff6b6b; color: white; font-weight: bold;")
        self.ctrl_c_btn.clicked.connect(lambda: self.send_signal(signal.SIGINT))
        signal_layout.addWidget(self.ctrl_c_btn)

        self.eof_btn = QPushButton("EOF")
        self.eof_btn.clicked.connect(self.send_eof)
        signal_layout.addWidget(self.eof_btn)

        self.kill_btn = QPushButton("Kill")
        self.kill_btn.setStyleSheet("background-color: #dc3545; color: white; font-weight: bold;")
        self.kill_btn.clicked.connect(lambda: self.send_signal(signal.SIGTERM))
        signal_layout.addWidget(self.kill_btn)

        # System integration buttons
        self.open_terminal_btn = QPushButton("Open Terminal Here")
        self.open_terminal_btn.clicked.connect(self.open_system_terminal)
        signal_layout.addWidget(self.open_terminal_btn)

        controls_layout.addLayout(signal_layout)
        left_layout.addLayout(controls_layout)

        # Status bar
        status_layout = QHBoxLayout()
        self.status_label = QLabel(f"CWD: {self.command_req.cwd}")
        self.shell_label = QLabel("Shell: bash")
        self.size_label = QLabel("80×24")
        self.exit_code_label = QLabel("Status: Ready")

        for label in [self.status_label, self.shell_label, self.size_label, self.exit_code_label]:
            label.setStyleSheet("color: #888; font-size: 10px; padding: 2px;")

        status_layout.addWidget(self.status_label)
        status_layout.addWidget(QLabel("|"))
        status_layout.addWidget(self.shell_label)
        status_layout.addWidget(QLabel("|"))
        status_layout.addWidget(self.size_label)
        status_layout.addStretch()
        status_layout.addWidget(self.exit_code_label)

        left_layout.addLayout(status_layout)
        main_layout.addWidget(left_widget, 1)

        # Right side - Command history
        self.history_widget = CommandHistoryWidget()
        self.history_widget.command_selected.connect(self.on_history_command_selected)
        self.history_widget.setMaximumWidth(300)
        main_layout.addWidget(self.history_widget)

        # Update terminal size display
        self.update_size_display()

        # Start PTY
        self.start_pty()

    def update_size_display(self):
        """Update terminal size display"""
        cols, rows = self.terminal.get_terminal_size()
        self.size_label.setText(f"{cols}×{rows}")

    def start_pty(self):
        """Start the PTY worker"""
        self.pty_worker = EnhancedPTYWorker(self.command_req, self.security_config)

        # Connect signals
        self.pty_worker.data_received.connect(self.terminal.append_output)
        self.pty_worker.process_finished.connect(self.on_process_finished)
        self.pty_worker.process_started.connect(self.on_process_started)
        self.pty_worker.error_occurred.connect(self.on_error)

        # Start the worker
        self.pty_worker.start()
        self.exit_code_label.setText("Status: Starting...")

    def on_process_started(self, pid: int):
        """Handle process start"""
        self.exit_code_label.setText(f"Status: Running (PID: {pid})")

    def on_process_finished(self, result: CommandResult):
        """Handle process completion"""
        self.current_result = result

        # Update status
        status_text = f"Status: Exited ({result.exit_code}) - {result.execution_time:.2f}s"
        if result.memory_used_mb > 0:
            status_text += f" - {result.memory_used_mb:.1f}MB"

        self.exit_code_label.setText(status_text)

        # Add to history
        if self.command_req.command_preview:
            self.history_widget.add_command(self.command_req.command_preview)

        # Log security violations if any
        if result.security_violations:
            self.terminal.append_output(f"\n⚠️ Security violations: {'; '.join(result.security_violations)}\n")

        # Enable input for new commands
        self.input_line.setEnabled(True)
        self.input_line.setFocus()

    def on_error(self, error_msg: str):
        """Handle errors"""
        self.terminal.append_output(f"\n❌ Error: {error_msg}\n")
        self.exit_code_label.setText("Status: Error")

    def send_input(self):
        """Send input to PTY"""
        text = self.input_line.text()
        if text and self.pty_worker:
            self.pty_worker.send_input(text + '\n')
            self.input_line.clear()

            # Add to history if it's a new command
            if text.strip():
                self.history_widget.add_command(text.strip())

    def send_signal(self, sig: signal.Signals):
        """Send signal to process"""
        if self.pty_worker:
            self.pty_worker.send_signal(sig)
            self.terminal.append_output(f"\n🔄 Sent signal: {sig.name}\n")

    def send_eof(self):
        """Send EOF to process"""
        if self.pty_worker:
            if sys.platform == 'win32':
                self.pty_worker.send_input('\x1a')  # Ctrl+Z on Windows
            else:
                self.pty_worker.send_input('\x04')  # Ctrl+D on Unix
            self.terminal.append_output("\n🔄 Sent EOF\n")

    def open_system_terminal(self):
        """Open system terminal at current working directory"""
        SystemIntegration.open_system_terminal(self.command_req.cwd)

    def on_history_command_selected(self, command: str):
        """Handle history command selection"""
        self.input_line.setText(command)
        self.input_line.setFocus()

    def resizeEvent(self, event):
        """Handle resize events"""
        super().resizeEvent(event)
        self.update_size_display()

        # Resize PTY
        if self.pty_worker:
            cols, rows = self.terminal.get_terminal_size()
            self.pty_worker.resize_pty(cols, rows)

    def closeEvent(self, event):
        """Handle tab close"""
        if self.pty_worker:
            self.pty_worker.stop()
            self.pty_worker.wait(1000)  # Wait up to 1 second
        event.accept()


class ConfigurationManager:
    """Configuration management for GUI settings"""

    def __init__(self, config_path: str = None):
        self.config_path = config_path or os.path.expanduser("~/.python_cockpit/gui_config.json")
        self.config = self.load_config()

    def load_config(self) -> Dict[str, Any]:
        """Load configuration from file"""
        default_config = {
            "security": {
                "level": "basic",
                "allowed_commands": [
                    "ls", "dir", "pwd", "cd", "echo", "cat", "type", "grep", "find",
                    "python", "pip", "git", "node", "npm", "docker", "kubectl",
                    "cli-multi-rapid"
                ],
                "blocked_commands": ["rm", "del", "format", "fdisk", "dd", "mkfs"],
                "max_execution_time": 300,
                "audit_commands": True
            },
            "terminal": {
                "font_family": "Consolas",
                "font_size": 10,
                "theme": "dark",
                "max_history": 100,
                "auto_scroll": True
            },
            "gui": {
                "window_width": 1200,
                "window_height": 800,
                "show_command_preview": True,
                "show_history": True,
                "confirm_dangerous_commands": True
            }
        }

        try:
            if os.path.exists(self.config_path):
                with open(self.config_path) as f:
                    loaded_config = json.load(f)
                    # Merge with defaults
                    for key, value in default_config.items():
                        if key not in loaded_config:
                            loaded_config[key] = value
                        elif isinstance(value, dict):
                            for subkey, subvalue in value.items():
                                if subkey not in loaded_config[key]:
                                    loaded_config[key][subkey] = subvalue
                    return loaded_config
        except Exception as e:
            logger.warning(f"Failed to load config: {e}")

        return default_config

    def save_config(self):
        """Save configuration to file"""
        try:
            os.makedirs(os.path.dirname(self.config_path), exist_ok=True)
            with open(self.config_path, 'w') as f:
                json.dump(self.config, f, indent=2)
        except Exception as e:
            logger.error(f"Failed to save config: {e}")

    def get_security_config(self) -> SecurityConfig:
        """Get security configuration"""
        sec_config = self.config.get("security", {})
        return SecurityConfig(
            level=SecurityLevel(sec_config.get("level", "basic")),
            allowed_commands=sec_config.get("allowed_commands", []),
            blocked_commands=sec_config.get("blocked_commands", []),
            max_execution_time=sec_config.get("max_execution_time", 300),
            audit_commands=sec_config.get("audit_commands", True),
            require_confirmation=sec_config.get("require_confirmation", [])
        )


class EnhancedMainWindow(QMainWindow):
    """Enhanced main GUI window with all features"""

    def __init__(self):
        super().__init__()
        self.config_manager = ConfigurationManager()
        self.security_config = self.config_manager.get_security_config()
        self.tab_counter = 0

        self.setup_ui()
        self.load_quick_actions()

    def setup_ui(self):
        """Setup main window UI"""
        self.setWindowTitle("CLI Multi-Rapid Enterprise Terminal")
        self.setGeometry(100, 100,
                        self.config_manager.config["gui"]["window_width"],
                        self.config_manager.config["gui"]["window_height"])

        # Set application icon
        self.setWindowIcon(self.style().standardIcon(QStyle.StandardPixmap.SP_ComputerIcon))

        # Central widget
        central_widget = QWidget()
        self.setCentralWidget(central_widget)
        layout = QVBoxLayout(central_widget)

        # Toolbar
        self.create_toolbar()

        # Main content area
        main_splitter = QSplitter(Qt.Orientation.Horizontal)

        # Left side - Quick Actions
        self.quick_actions_widget = self.create_quick_actions_widget()
        main_splitter.addWidget(self.quick_actions_widget)

        # Center - Terminal tabs
        self.tab_widget = QTabWidget()
        self.tab_widget.setTabsClosable(True)
        self.tab_widget.tabCloseRequested.connect(self.close_tab)
        main_splitter.addWidget(self.tab_widget)

        # Right side - System info (optional)
        self.system_info_widget = self.create_system_info_widget()
        main_splitter.addWidget(self.system_info_widget)

        # Set splitter proportions
        main_splitter.setSizes([250, 800, 150])
        layout.addWidget(main_splitter)

        # Status bar
        self.create_status_bar()

        # Create initial terminal
        self.create_new_terminal()

    def create_toolbar(self):
        """Create application toolbar"""
        toolbar = self.addToolBar("Main")
        toolbar.setStyleSheet("""
            QToolBar {
                background-color: #2d2d2d;
                border: 1px solid #3c3c3c;
                spacing: 3px;
            }
            QToolButton {
                background-color: #404040;
                color: white;
                border: 1px solid #555;
                padding: 5px 10px;
                margin: 1px;
            }
            QToolButton:hover {
                background-color: #505050;
            }
            QToolButton:pressed {
                background-color: #606060;
            }
        """)

        # New terminal action
        new_terminal_action = QAction("New Terminal", self)
        new_terminal_action.setShortcut("Ctrl+T")
        new_terminal_action.triggered.connect(self.create_new_terminal)
        toolbar.addAction(new_terminal_action)

        toolbar.addSeparator()

        # Settings action
        settings_action = QAction("Settings", self)
        settings_action.triggered.connect(self.show_settings)
        toolbar.addAction(settings_action)

        # Help action
        help_action = QAction("Help", self)
        help_action.triggered.connect(self.show_help)
        toolbar.addAction(help_action)

        toolbar.addSeparator()

        # System terminal action
        system_terminal_action = QAction("Open System Terminal", self)
        system_terminal_action.triggered.connect(lambda: SystemIntegration.open_system_terminal())
        toolbar.addAction(system_terminal_action)

    def create_quick_actions_widget(self) -> QWidget:
        """Create quick actions panel"""
        widget = QWidget()
        widget.setMaximumWidth(250)
        widget.setStyleSheet("""
            QWidget {
                background-color: #2d2d2d;
                color: white;
            }
        """)

        layout = QVBoxLayout(widget)

        # Title
        title = QLabel("Quick Actions")
        title.setStyleSheet("font-weight: bold; font-size: 12px; padding: 5px;")
        layout.addWidget(title)

        # Scroll area for actions
        scroll = QScrollArea()
        scroll.setWidgetResizable(True)
        scroll.setStyleSheet("""
            QScrollArea {
                border: 1px solid #3c3c3c;
            }
        """)

        self.actions_container = QWidget()
        self.actions_layout = QVBoxLayout(self.actions_container)
        scroll.setWidget(self.actions_container)
        layout.addWidget(scroll)

        return widget

    def create_system_info_widget(self) -> QWidget:
        """Create system information panel"""
        widget = QWidget()
        widget.setMaximumWidth(200)
        widget.setStyleSheet("""
            QWidget {
                background-color: #2d2d2d;
                color: white;
            }
        """)

        layout = QVBoxLayout(widget)

        # Title
        title = QLabel("System Info")
        title.setStyleSheet("font-weight: bold; font-size: 12px; padding: 5px;")
        layout.addWidget(title)

        # System information
        self.system_info_text = QTextEdit()
        self.system_info_text.setReadOnly(True)
        self.system_info_text.setStyleSheet("""
            QTextEdit {
                background-color: #1e1e1e;
                color: #ffffff;
                border: 1px solid #3c3c3c;
                font-family: monospace;
                font-size: 9px;
            }
        """)

        # Update system info
        self.update_system_info()
        layout.addWidget(self.system_info_text)

        return widget

    def update_system_info(self):
        """Update system information display"""
        import platform

        import psutil

        try:
            info = f"""System: {platform.system()} {platform.release()}
Python: {platform.python_version()}
CPU: {psutil.cpu_count()} cores
Memory: {psutil.virtual_memory().total // (1024**3)} GB
Disk: {psutil.disk_usage('/').total // (1024**3) if os.name != 'nt' else psutil.disk_usage('C:\\').total // (1024**3)} GB

Active Terminals: {self.tab_widget.count()}
Security Level: {self.security_config.level.value}
"""
        except Exception as e:
            info = f"System information unavailable: {e}"

        self.system_info_text.setPlainText(info)

    def create_status_bar(self):
        """Create status bar"""
        status_bar = self.statusBar()
        status_bar.setStyleSheet("""
            QStatusBar {
                background-color: #2d2d2d;
                color: white;
                border-top: 1px solid #3c3c3c;
            }
        """)

        # Ready message
        status_bar.showMessage("Ready - CLI Multi-Rapid Enterprise Terminal")

    def load_quick_actions(self):
        """Load quick actions from configuration"""
        # Sample quick actions - in real implementation, load from config
        actions = [
            {
                "label": "CLI Help",
                "command": "cli-multi-rapid --help",
                "category": "CLI Platform",
                "tooltip": "Show CLI Multi-Rapid help"
            },
            {
                "label": "System Status",
                "command": "cli-multi-rapid system status",
                "category": "CLI Platform",
                "tooltip": "Check system status"
            },
            {
                "label": "List Directory",
                "command": "ls -la" if sys.platform != 'win32' else "dir",
                "category": "System",
                "tooltip": "List current directory contents"
            },
            {
                "label": "Python Version",
                "command": "python --version",
                "category": "Development",
                "tooltip": "Check Python version"
            },
            {
                "label": "Git Status",
                "command": "git status",
                "category": "Git",
                "tooltip": "Show git repository status"
            }
        ]

        # Group actions by category
        categories = {}
        for action in actions:
            category = action["category"]
            if category not in categories:
                categories[category] = []
            categories[category].append(action)

        # Create buttons for each category
        for category, category_actions in categories.items():
            # Category header
            header = QLabel(category)
            header.setStyleSheet("""
                font-weight: bold;
                color: #4CAF50;
                padding: 5px 2px 2px 2px;
                border-bottom: 1px solid #3c3c3c;
                margin-top: 5px;
            """)
            self.actions_layout.addWidget(header)

            # Action buttons
            for action in category_actions:
                btn = QPushButton(action["label"])
                btn.setToolTip(action["tooltip"])
                btn.setStyleSheet("""
                    QPushButton {
                        background-color: #404040;
                        color: white;
                        border: 1px solid #555;
                        padding: 8px 12px;
                        text-align: left;
                        margin: 2px;
                    }
                    QPushButton:hover {
                        background-color: #505050;
                    }
                    QPushButton:pressed {
                        background-color: #606060;
                    }
                """)
                btn.clicked.connect(lambda checked, cmd=action["command"]: self.run_quick_action(cmd))
                self.actions_layout.addWidget(btn)

        # Add spacer
        self.actions_layout.addStretch()

    def run_quick_action(self, command: str):
        """Run a quick action command"""
        self.create_terminal_with_command(command)

    def create_new_terminal(self):
        """Create a new terminal tab"""
        # Default command request
        request = CommandRequest(
            tool="bash" if sys.platform != 'win32' else "cmd",
            args=[],
            cwd=os.getcwd(),
            env=os.environ.copy(),
            command_preview="Interactive shell",
            shell=False
        )

        self.create_terminal_tab(request)

    def create_terminal_with_command(self, command: str):
        """Create terminal tab with specific command"""
        # Parse command safely
        try:
            args = shlex.split(command, posix=(sys.platform != 'win32'))
            tool = args[0] if args else "echo"
            cmd_args = args[1:] if len(args) > 1 else []
        except ValueError:
            # Fallback for complex commands
            tool = "bash" if sys.platform != 'win32' else "cmd"
            cmd_args = ["-c", command] if sys.platform != 'win32' else ["/C", command]

        request = CommandRequest(
            tool=tool,
            args=cmd_args,
            cwd=os.getcwd(),
            env=os.environ.copy(),
            command_preview=command,
            shell=sys.platform == 'win32'  # Use shell on Windows
        )

        self.create_terminal_tab(request)

    def create_terminal_tab(self, request: CommandRequest):
        """Create a new terminal tab"""
        self.tab_counter += 1

        # Confirm dangerous commands
        if (self.config_manager.config["gui"]["confirm_dangerous_commands"] and
            request.tool in self.security_config.require_confirmation):

            reply = QMessageBox.question(
                self,
                "Confirm Command",
                f"Are you sure you want to run this potentially dangerous command?\n\n{request.command_preview}",
                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
            )

            if reply == QMessageBox.StandardButton.No:
                return

        # Create terminal tab
        terminal_tab = EnhancedTerminalTab(request, self.security_config)

        # Add tab
        tab_title = f"Terminal {self.tab_counter}"
        if request.tool != "bash" and request.tool != "cmd":
            tab_title = f"{request.tool} {self.tab_counter}"

        self.tab_widget.addTab(terminal_tab, tab_title)
        self.tab_widget.setCurrentWidget(terminal_tab)

        # Update system info
        self.update_system_info()

    def close_tab(self, index: int):
        """Close terminal tab"""
        widget = self.tab_widget.widget(index)
        if widget:
            widget.close()
        self.tab_widget.removeTab(index)
        self.update_system_info()

    def show_settings(self):
        """Show settings dialog"""
        dialog = QDialog(self)
        dialog.setWindowTitle("Settings")
        dialog.setModal(True)
        dialog.resize(500, 400)

        layout = QVBoxLayout(dialog)

        # Settings content
        settings_text = QTextEdit()
        settings_text.setPlainText(json.dumps(self.config_manager.config, indent=2))
        layout.addWidget(settings_text)

        # Buttons
        buttons = QHBoxLayout()
        save_btn = QPushButton("Save")
        cancel_btn = QPushButton("Cancel")

        def save_settings():
            try:
                new_config = json.loads(settings_text.toPlainText())
                self.config_manager.config = new_config
                self.config_manager.save_config()
                self.security_config = self.config_manager.get_security_config()
                dialog.accept()
            except Exception as e:
                QMessageBox.warning(dialog, "Error", f"Invalid JSON: {e}")

        save_btn.clicked.connect(save_settings)
        cancel_btn.clicked.connect(dialog.reject)

        buttons.addWidget(save_btn)
        buttons.addWidget(cancel_btn)
        layout.addLayout(buttons)

        dialog.exec()

    def show_help(self):
        """Show help dialog"""
        help_text = """
CLI Multi-Rapid Enterprise Terminal

Keyboard Shortcuts:
- Ctrl+T: New Terminal
- Ctrl+W: Close Tab
- Ctrl+Q: Quit Application

Features:
- Real PTY terminals with full ANSI support
- Command history and search
- Security validation and sandboxing
- Quick Actions for common commands
- System integration (open system terminal)
- Configurable security levels

Security Levels:
- Unrestricted: No command filtering
- Basic: Block dangerous commands
- Strict: Allow only whitelisted commands
- Paranoid: Maximum security with audit logging

For more information, visit the documentation.
        """

        QMessageBox.information(self, "Help", help_text)

    def closeEvent(self, event):
        """Handle application close"""
        # Close all terminal tabs
        for i in range(self.tab_widget.count()):
            widget = self.tab_widget.widget(i)
            if widget:
                widget.close()

        # Save configuration
        self.config_manager.save_config()

        event.accept()


def main():
    """Main application entry point"""
    import sys

    # Create QApplication
    app = QApplication(sys.argv)
    app.setStyle('Fusion')  # Use Fusion style for better cross-platform appearance

    # Set dark theme
    app.setStyleSheet("""
        QApplication {
            background-color: #2d2d2d;
            color: white;
        }
        QMainWindow {
            background-color: #2d2d2d;
        }
        QTabWidget::pane {
            border: 1px solid #3c3c3c;
            background-color: #1e1e1e;
        }
        QTabBar::tab {
            background-color: #404040;
            color: white;
            padding: 8px 12px;
            margin-right: 2px;
            border-top-left-radius: 4px;
            border-top-right-radius: 4px;
        }
        QTabBar::tab:selected {
            background-color: #1e1e1e;
        }
        QTabBar::tab:hover {
            background-color: #505050;
        }
    """)

    # Create and show main window
    window = EnhancedMainWindow()
    window.show()

    # Run application
    sys.exit(app.exec())


if __name__ == "__main__":
    main()
